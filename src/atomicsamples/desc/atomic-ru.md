# Atomic в Java
Когда несколько потоков одновременно работают с общими данными,
возникает необходимость в защите этих данных от одновременного изменения, что может привести к непредсказуемым результатам.
Это явление называется Race Condition (состояние гонки).
В Java для решения таких проблем и обеспечения безопасного доступа к данным в многозадачной среде можно использовать атомарные операции.
Они предоставляют способ выполнения операций над переменными так,
что эти операции выполняются как единое целое и не могут быть прерваны другими потоками.

## Что такое атомарные операции?
Атомарные операции — это такие операции, которые выполняются полностью или не выполняются вообще,
не позволяя другим потокам вмешиваться в процесс.
В Java атомарные операции можно реализовать с помощью класса `AtomicInteger` и других классов из пакета `java.util.concurrent.atomic`,
которые обеспечивают безопасный доступ к примитивным типам данных и коллекциям без необходимости использовать синхронизацию.

## Зачем нужны атомарные операции?
1. **Избежание состояния гонки**: Когда несколько потоков одновременно изменяют одну и ту же переменную,
без атомарных операций может возникнуть ошибка, известная как **Race Condition**. Атомарные операции обеспечивают,
что обновление переменной будет выполнено атомарно, без вмешательства других потоков.
2. **Производительность**: Атомарные операции не требуют блокировок, как это происходит при использовании синхронизации.
Это снижает накладные расходы, связанные с блокировками, и повышает производительность, особенно в многопоточных приложениях.
3. **Простота и удобство**: Использование классов из пакета `java.util.concurrent.atomic` позволяет легко реализовывать 
безопасные многопоточные операции без необходимости вручную синхронизировать блоки кода или методы.

## Пример с ошибкой: Без атомарных операций
В следующем примере два потока одновременно увеличивают значение переменной value, что приводит к Race Condition.
```java
public class BadCode {
    static int value = 0;

    public static void main(String[] args) throws InterruptedException {
        for (int i = 0; i < 10_000; i++) {
            new MyThread().start();
        }
        Thread.sleep(2_000);
        System.out.println("Value = " + value);
    }

    static class MyThread extends Thread {
        @Override
        public void run() {
            value++; // Несогласованное изменение переменной
        }
    }
}
```
В этом примере создается 10 000 потоков, каждый из которых увеличивает переменную value.
Однако без синхронизации или атомарных операций два потока могут одновременно прочитать одно и то же значение value,
увеличить его и записать обратно, что приведет к потере значений и ошибочному результату.
Результат выполнения программы будет непредсказуемым,
и вместо ожидаемого значения 10 000 переменная может иметь гораздо меньший результат
```text
Value = 9998

Process finished with exit code 0
```

## Пример с использованием атомарных операций: Решение проблемы
Вместо использования обычной переменной типа int, мы можем использовать AtomicInteger,
который предоставляет атомарные операции для работы с целочисленными значениями.

```java
public class GoodCode {
    static AtomicInteger value = new AtomicInteger(0);

    public static void main(String[] args) throws InterruptedException {
        for (int i = 0; i < 10_000; i++) {

            new MyThread().start();
        }
        Thread.sleep(2_000);
        System.out.println("Value = " + value.get());
    }

    static class MyThread extends Thread {
        @Override
        public void run() {
            value.incrementAndGet();
        }
    }
}
```
Здесь вместо обычной переменной int используется AtomicInteger, который предоставляет метод incrementAndGet().
Этот метод увеличивает значение атомарно, то есть операция выполнения инкремента не может быть прервана другим потоком.
Благодаря этому результат работы программы будет всегда правильным, и переменная value всегда будет равна 10 000.
```text
Value = 10000

Process finished with exit code 0
```

## Как работают атомарные операции?
Атомарные операции в Java реализуются с помощью механизма, называемого CAS (Compare and Swap),
который используется в классах типа AtomicInteger. Это позволяет выполнять операции без блокировок, но с гарантией,
что данные не будут повреждены в процессе. Когда поток выполняет атомарную операцию, он не блокирует другие потоки,
а использует специальный алгоритм, который позволяет гарантировать, что операция выполнится корректно,
если данные не изменились с момента их последнего чтения. Если данные были изменены другим потоком,
операция может быть повторена.







